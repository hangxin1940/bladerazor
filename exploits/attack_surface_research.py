from textwrap import dedent

from crewai import Agent, Task, Crew
from crewai_tools import BaseTool

from persistence.database import DB
from config import logger
from rag.rag import RAG
from rag.rag_search_tool import RagSearchTool


class AttackSurfaceResearch:
    """
    攻击面研究
    根据已探明的网络资产，进行漏洞分析与利用。
    """

    def __init__(self, db: DB, rag: RAG, llm=None, verbose: bool = False):
        self.llm = llm
        self.db = db
        self.rag = rag
        self.verbose = verbose

    def task_attack_surface_research(self, agent: Agent, target: str) -> Task:
        logger.info("初始化任务 攻击面研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                对目标的技术栈、指纹信息、暴露的端口服务以及漏扫结果进行深入分析研究，以找到所有可能的攻击面。
    
                {target}
                """),
            expected_output=dedent(
                """
                最终答案是你发现的所有攻击面列表。
                """),
        )

    def task_establishing_foothold_research_rework(self, agent: Agent, plan: str, review: str) -> Task:
        logger.info("初始化任务 打点研究返工")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                根据攻击计划的审核结果，重新研究。
                
                攻击计划:
                {plan}
                
                审核结果:
                {review}                
                """),
            expected_output=dedent(
                """
                最终答案是每个攻击面的漏洞利用方法，根据严重程度排序，越详细越好。你是攻击队，不需要修复建议，不要编造答案。
                """),
        )

    def task_establishing_foothold_research(self, agent: Agent) -> Task:
        logger.info("初始化任务 打点研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                根据攻击面列表，结合本地知识库，为每一个攻击面找到所有攻击方法。
       
                注意一些基本原则:
                * 不需要技术检测类的方案，如指纹识别等。
                * 注意产品一致性，如Microsoft Office的漏洞不适用于WorldPress，Windows的漏洞不适用于Linux。
                * 注意漏洞与目标是否匹配，如一个java框架的漏洞并不适用于一个php框架。
                * 注意漏洞的利用条件，如是否需要登录、是否需要特定的请求等。
                * 注意漏洞的利用方法，如是否需要上传文件、是否需要执行命令等。
                * 注意漏洞的风险等级，如是否可以获取root权限、是否可以获取敏感信息等。
                * 注意漏洞的利用复杂度，如是否需要特定的环境、是否需要特定的工具等。
                * 如果前置为CDN，则很大概率存在WAF，需要考虑绕过WAF的方法或者找到原始服务器的方法。
                * 对于配置不当造成的安全类威胁，仅关注会对目标造成实质性影响的漏洞，如信息泄漏、XSS攻击等。
    
                你应当确认漏洞的类型、风险等级以及利用复杂度。
                """),
            expected_output=dedent(
                """
                最终答案是每个攻击面的漏洞利用方法，根据严重程度排序，越详细越好。
                你是攻击队，不需要修复建议，不要编造答案。
                攻击步骤、攻击方法、攻击工具、攻击风险等都需要详细描述。
                """),
        )

    def agent_establishing_foothold_research_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 打点研究专家")
        agent = Agent(
            role='打点研究专家',
            goal='根据目标的已知情报，结合本地知识库，研究并制定一套渗透方案',
            backstory=dedent(
                """
                你是一名经验丰富的打点研究专家，隶属于攻击团队。
                你的主要任务是利用已知的各种情报，对目标制定一套渗透方案。
                不要给出修复建议，只需要给出攻击方案。
                攻击步骤、攻击方法、攻击工具、攻击风险等都需要详细描述。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=True,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def _getKnowledgeTools(self) -> []:
        tools = []
        tools.append(RagSearchTool(self.rag))
        return tools

    def establishingFootholdResearchCrew(self, target: str):
        agents = []
        tasks = []
        tools = self._getKnowledgeTools()

        ag = self.agent_establishing_foothold_research_expert(self.llm, tools)
        agents.append(ag)

        tasks.append(self.task_attack_surface_research(ag, target))
        tasks.append(self.task_establishing_foothold_research(ag))

        logger.info("初始化智能体 打点研究")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False,
            cache=True
        )

    def task_attack_plan_review(self, agent: Agent, assets: str, plan: str) -> Task:
        logger.info("初始化任务 攻击方案审核")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                结合本地知识库, 对攻击面与攻击计划进行审核。
                你只需要审核攻击面与攻击计划是否匹配。
                
                注意一些基本原则:
                * 攻击方案可能很长，不要因为一点而全盘否定。
                * 不能因为攻击面缺失实体而否定攻击方案。
                * 注意漏洞与目标是否匹配，如一个java框架的漏洞并不适用于一个php框架。
                * 注意漏洞的利用条件，如操作系统是否与目标匹配。
                * 不能遗漏高危攻击面。
                * 不要混淆目标实体与漏洞实体。目标实体是你要进行渗透的对象，漏洞实体是漏洞的利用条件、特性以及关联的程序类型等信息的集合。
                
                攻击面:
                {assets}
                
                攻击计划:
                {plan}
                """),
            expected_output=dedent(
                """
                最终答案为三种类型。
                
                如果审核通过：
                    只需要回答字符串`PASS`
                如果不通过且方案完全不可行:
                    以字符串`FAIL`开头，后面跟上不可行的原因
                如果不通过但需要优化:
                    则返回优化后的攻击方案
                """),
        )

    def agent_attack_plan_review_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 攻击方案审核专家")
        agent = Agent(
            role='攻击方案审核专家',
            goal='根据目标的已知情报，结合本地知识库，对攻击方案进行审核',
            backstory=dedent(
                """
                你是一名经验丰富的攻击方案审核专家，隶属于攻击团队。
                你的主要任务是利用已知的各种情报与知识对攻击方案进行审核。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                
                你很清楚的了解:
                * 没有绝对的安全，只有相对的安全。
                * 一个好的攻击方案是成功的一半。
                * 防火墙并不是你的阻碍，总有绕过的方法。
                * 你的工作是找到最佳的攻击方案，而不是找到最多的攻击方案。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=True,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def attackPlanReviewCrew(self, assets: str, plan: str, review: str | None = None):
        agents = []
        tasks = []
        tools = self._getKnowledgeTools()

        ag = self.agent_attack_plan_review_expert(self.llm, tools)
        agents.append(ag)

        tasks.append(self.task_attack_surface_research(ag, assets))
        tasks.append(self.task_establishing_foothold_research(ag))
        tasks.append(self.task_attack_plan_review(ag, assets, plan))

        if review is not None:
            tasks.append(self.task_establishing_foothold_research_rework(ag, plan, review))

        logger.info("初始化智能体 攻击方案审核")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False,
            cache=True
        )
