from textwrap import dedent

from crewai import Agent, Task, Crew
from crewai_tools import BaseTool

from persistence.database import DB
from config import logger
from rag.rag import RAG
from rag.rag_search_tool import RagSearchTool


class AttackSurfaceResearch:
    """
    攻击面研究
    根据已探明的网络资产，进行漏洞分析与利用。
    """

    def __init__(self, db: DB, rag: RAG, llm=None, verbose: bool = False):
        self.llm = llm
        self.db = db
        self.rag = rag
        self.verbose = verbose

    def _getKnowledgeTools(self) -> []:
        tools = []
        tools.append(RagSearchTool(self.rag, self.llm, self.verbose))
        return tools

    def task_information_leak_research(self, agent: Agent, assets: str) -> Task:
        logger.info("初始化任务 信息泄露研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""                  
                识别并分析有用的实体，需要注意以下几点：
                * 实体可能是敏感信息，如密码、密钥等。
                * 实体可能是系统信息，如版本信息、路径信息等。
                * 实体可能是配置信息，如数据库配置、系统配置等。
                * 实体可能是用户信息，如用户名等。
        
                请特别留意以下资产：
                {assets}
                """),
            expected_output=dedent(
                """
                最终答案应包括你发现的所有敏感信息的列表。
                只输出已发现的敏感信息。
                不要将原始输入作为输出。
                确保信息分类明确，例如：密码、密钥、版本信息、路径信息、数据库配置、系统配置、用户名等。
                """),
        )

    def agent_intelligence_analysis_expert(self, llm=None) -> Agent:
        logger.info("初始化代理 情报分析专家")
        agent = Agent(
            role='情报分析专家',
            goal='根据目标的所有信息，提取有用的情报，为后续工作提供支持',
            backstory=dedent(
                """
                你是一名经验丰富的情报分析专家，隶属于攻击团队。
                你的主要任务是利用目标的所有已知信息，查找对工作有利的情报。
                你擅长发现潜在的情报，如敏感信息、漏洞信息等，这些信息有助于了解系统结构并找到潜在漏洞。
        
                以下是需要特别注意的方面，包括但不限于：
                * 源代码
                * 注释
                * 隐藏字段
                * 错误信息
                * 错误页面中的堆栈跟踪信息
                * 版本信息
                * 文件路径
                * 电子邮件地址
                * IP地址
                * Meta标签
                * SQL报错信息
        
                通过详细分析这些方面的信息，你将能够提取有用的情报，为团队的后续工作提供关键支持。
                """),
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def intelligenceAnalysisCrew(self, target: str):
        agents = []
        tasks = []

        agiae = self.agent_intelligence_analysis_expert(self.llm)
        agents.append(agiae)
        tasks.append(self.task_information_leak_research(agiae, target))

        logger.info("初始化智能体 情报分析")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False,
            cache=False
        )

    def task_attack_surface_research(self, agent: Agent, target: str, intelligence: str) -> Task:
        logger.info("初始化任务 攻击面研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                对目标的技术栈、指纹信息、暴露的端口服务、漏扫结果以及掌握的情报进行深入分析研究，以找到所有可能的攻击面。

                你应当遵循以下思路：
                1. 目标是CMS还是程序？例如WordPress或phpMyAdmin。
                    确定目标类型后，才能找到对应的漏洞。
                2. 哪些前置代理了流量？例如CDN、Nginx或Apache。
                    有些程序自带前置（如Go），有些程序需要前置代理（如PHP需要Nginx或Apache）。
                    如果存在前置，那么需要分别找漏洞，甚至有些漏洞需要前置与后端配合。
                3. 有哪些情报可以利用？
                    如果页面中包含一些敏感信息（如报错信息、注释、路径等），这些信息有助于推测目标程序及版本。
        
                按上述思路操作，避免发生低级错误（如在PHP的目标上找Java的漏洞）。
        
                需要注意的方面包括但不限于以下内容：
                * 对于已明确指纹信息的目标，根据指纹信息找到对应的漏洞。
                * 不要错误地将其他产品的漏洞应用到目标上。
                * 注意产品一致性，例如Microsoft Office的漏洞不适用于WordPress，Windows的漏洞不适用于Linux。
                * 确保漏洞与目标匹配，例如Java框架的漏洞不适用于PHP框架。
                * 考虑漏洞的利用条件，例如是否需要登录、是否需要特定的请求等。
                * 描述漏洞的利用方法，例如是否需要上传文件、是否需要执行命令等。
                * 评估漏洞的风险等级，例如是否可以获取root权限、是否可以获取敏感信息等。
                * 考虑漏洞的利用复杂度，例如是否需要特定的环境、是否需要特定的工具等。
                * 如果前置有CDN，可能存在WAF，需要考虑绕过WAF的方法或找到原始服务器的方法。
                * 对于配置不当造成的安全威胁，仅关注对目标造成实质性影响的漏洞（如信息泄漏、XSS攻击等）。
        
                使用错误的漏洞攻击已确定程序（如使用PHP的漏洞攻击Java程序）将会造成灾难性后果！
        
                目标：
                {target}
        
                已掌握的情报：
                {intelligence}
                """),
            expected_output=dedent(
                """
                最终答案应包括你发现的所有攻击面列表，并根据严重程度排序，越详细越好。
                确保每个攻击面都包含以下信息：
                * 攻击步骤
                * 攻击方法
                * 使用工具
                * 攻击风险
                * 可能的漏洞利用条件和方法
                * 漏洞的风险等级和利用复杂度
                """),
        )

    def task_establishing_foothold_research_rework(self, agent: Agent, plan: str,
                                                   review: str) -> Task:
        logger.info("初始化任务 打点研究返工")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                根据攻击计划的审核结果，重新进行研究，确保所有潜在攻击面都得到充分考虑。

                攻击计划:
                {plan}
        
                审核结果:
                {review}
        
                你需要进行以下步骤：
                1. 分析审核结果，找出需要修改或补充的部分。
                2. 重新评估每个攻击面，确保考虑到所有可能的漏洞。
                3. 对每个攻击面进行详细研究，找出可能的漏洞利用方法。
                4. 根据严重程度对漏洞进行排序，确保最关键的漏洞优先处理。
                5. 确保研究结果详细，包括漏洞的利用条件、方法、工具、风险等级和利用复杂度。
        
                避免低级错误，例如将不适用于目标系统的漏洞应用到目标上。 
                """),
            expected_output=dedent(
                """
                最终答案应包括每个攻击面的漏洞利用方法，并根据严重程度排序，越详细越好。你是攻击队的一员，不需要提供修复建议，不要编造答案。
        
                确保每个漏洞描述包括：
                * 攻击步骤
                * 攻击方法
                * 使用工具
                * 攻击风险
                * 漏洞的利用条件和方法
                * 漏洞的风险等级和利用复杂度
                """),
        )

    def task_establishing_foothold_research(self, agent: Agent) -> Task:
        logger.info("初始化任务 打点研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                根据攻击面列表，结合本地知识库，为每一个攻击面找到所有攻击方法。

                请遵循以下原则：
                * 不需要技术检测类的方案，如指纹识别等。
                * 对于已明确指纹信息的目标，需要根据指纹信息找到对应的漏洞。
                * 不要错误地将其他产品的漏洞应用到目标上。
                * 注意产品一致性，例如Microsoft Office的漏洞不适用于WordPress，Windows的漏洞不适用于Linux。
                * 确保漏洞与目标匹配，例如Java框架的漏洞不适用于PHP框架。
                * 考虑漏洞的利用条件，例如是否需要登录、是否需要特定的请求等。
                * 描述漏洞的利用方法，例如是否需要上传文件、是否需要执行命令等。
                * 评估漏洞的风险等级，例如是否可以获取root权限、是否可以获取敏感信息等。
                * 考虑漏洞的利用复杂度，例如是否需要特定的环境、是否需要特定的工具等。
                * 如果前置有CDN，可能存在WAF，需要考虑绕过WAF的方法或找到原始服务器的方法。
                * 对于配置不当造成的安全威胁，仅关注对目标造成实质性影响的漏洞（如信息泄漏、XSS攻击等）。
        
                你应当确认每个漏洞的类型、风险等级以及利用复杂度。
        
                避免低级错误，例如在已确定技术栈的程序中使用错误的漏洞（如使用PHP的漏洞攻击Java程序），这将会造成灾难性后果！
                """),
            expected_output=dedent(
                """
                最终答案应包括每个攻击面的漏洞利用方法，并根据严重程度排序，越详细越好。你是攻击队的一员，不需要提供修复建议，不要编造答案。

                确保每个漏洞描述包括：
                * 攻击步骤
                * 攻击方法
                * 使用工具
                * 攻击风险
                * 漏洞的利用条件和方法
                * 漏洞的风险等级和利用复杂度
                """),
        )

    def agent_establishing_foothold_research_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 打点研究专家")
        agent = Agent(
            role='打点研究专家',
            goal='根据目标的已知情报，结合本地知识库，研究并制定一套渗透方案',
            backstory=dedent(
                """
                你是一名经验丰富的打点研究专家，隶属于攻击团队。
                你的主要任务是利用已知的各种情报，对目标制定一套详细且可执行的渗透方案。
                方案中不需要给出修复建议，而是专注于攻击策略的制定。
        
                任务要求：
                1. 利用RAG搜索工具，围绕目标的技术栈进行深入搜索。
                2. 详细描述每一步攻击步骤、方法、工具以及可能的攻击风险。
                3. 输出的攻击方案需要包括：
                    - 攻击路径的选择
                    - 可能的攻击入口点
                    - 每个步骤的具体执行方法
                    - 所需工具及其使用方法
                    - 潜在的风险评估及规避策略
                    
                使用搜索工具如RAG时应注意以下几点：
                1. 应使用详细的关键词，针对性地搜索与目标技术栈相关的漏洞和配置缺陷。
                2. 避免查询与目标明显不相关的内容，如特定的IP、域名或无关的技术栈。
                3. 系统性的审核这些工具的输出，确保每项结果都与实际的安全目标直接相关。
                    审核过程中应遵循的步骤包括：
                    1. 核实每一条输出结果是否与搜索关键词直接相关。任何与查询技术栈不符的结果都应被标记为不相关。
                    2. 识别和记录结果中的任何可能误导的信息，如错误的技术细节或与查询不符的上下文。
                    3. 对每个不相关或误导性的结果提供简要的分析说明，解释为什么这些结果不适合当前的搜索需求。
                    4. 提出修改搜索策略的建议，如更换或细化关键词，以提高未来搜索的相关性和效果。
                    
                    示例：
                        搜索关键词：'Apache Struts OGNL injection'
                        搜索结果：'Apache Struts version 2.3.31 RCE vulnerability details'
                        审核步骤：确认搜索结果与关键词的相关性，验证漏洞详情的准确性和目标系统的适用性。
                    
                        如果结果涉及到不相关的框架，如'.NET framework vulnerability'，则标记为不相关，并在报告中指出。
        
                你的工作至关重要，攻击方案的质量将直接影响团队后续工作的开展和成功率。
                
                如果无法找到合适的攻击方案，直接输出字符串`FAIL`。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def establishingFootholdResearchCrew(self, target: str, intelligence: str):
        agents = []
        tasks = []
        tools = self._getKnowledgeTools()

        ag = self.agent_establishing_foothold_research_expert(self.llm, tools)
        agents.append(ag)

        tasks.append(self.task_attack_surface_research(ag, target, intelligence))
        tasks.append(self.task_establishing_foothold_research(ag))

        logger.info("初始化智能体 打点研究")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False,
            cache=False
        )

    def task_attack_plan_review(self, agent: Agent, assets: str, intelligence: str, plan: str) -> Task:
        logger.info("初始化任务 攻击方案审核")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                结合本地知识库，对攻击面与攻击计划进行审核。
                你的任务是审核攻击面与攻击计划是否匹配。
        
                审核思路：
                1. 目标的技术栈是否明确？
                    确认方案是否按照已知情报正确识别出目标的程序（如WordPress或phpMyAdmin）。
                2. 使用的漏洞是否匹配目标技术栈？
                    确认方案是否使用了与目标技术栈不匹配的漏洞（如使用PHP的漏洞攻击Java程序）。
                    如果使用了不匹配的漏洞，请移除相应方案。
        
                基本原则：
                * 攻击方案可能很长，不要因为一点而全盘否定。
                * 不要因为攻击面缺失实体而否定攻击方案。
                * 确保漏洞与目标匹配（如Java框架的漏洞不适用于PHP框架）。
                * 注意漏洞的利用条件（如操作系统是否与目标匹配）。
                * 不能遗漏高危攻击面。
                * 不要混淆目标实体与漏洞实体。目标实体是你要进行渗透的对象，漏洞实体是漏洞的利用条件、特性以及关联的程序类型等信息的集合。
                * 如果仅有少部分不合理，可以提出优化建议，而非直接否决。
        
                避免低级错误，例如对已确定技术栈的程序使用错误的漏洞（如使用PHP的漏洞攻击Java程序），这将会造成灾难性后果。
        
                审核内容：
                攻击面：
                {assets}
        
                已掌握的情报：
                {intelligence}
        
                攻击计划：
                {plan}
                """),
            expected_output=dedent(
                """
                最终答案应为以下三种类型之一：
                
                如果审核通过：
                    只需要回答字符串`PASS`
                如果不通过且方案完全不可行：
                    以字符串`FAIL`开头，后面跟上不可行的原因
                如果不通过但需要优化：
                    返回优化后的攻击方案，并以字符串`OPTIMIZE`开头
                """),
        )

    def agent_attack_plan_review_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 攻击方案审核专家")
        agent = Agent(
            role='攻击方案审核专家',
            goal='根据目标的已知情报，结合本地知识库，对攻击方案进行审核',
            backstory=dedent(
                """
                你是一名经验丰富的攻击方案审核专家，隶属于攻击团队。
                你的主要任务是利用已知的各种情报与知识对攻击方案进行审核。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                
                使用搜索工具如RAG时应注意以下几点：
                1. 应使用详细的关键词，针对性地搜索与目标技术栈相关的漏洞和配置缺陷。
                2. 避免查询与目标明显不相关的内容，如特定的IP、域名或无关的技术栈。
                3. 系统性的审核这些工具的输出，确保每项结果都与实际的安全目标直接相关。
                    审核过程中应遵循的步骤包括：
                    1. 核实每一条输出结果是否与搜索关键词直接相关。任何与查询技术栈不符的结果都应被标记为不相关。
                    2. 识别和记录结果中的任何可能误导的信息，如错误的技术细节或与查询不符的上下文。
                    3. 对每个不相关或误导性的结果提供简要的分析说明，解释为什么这些结果不适合当前的搜索需求。
                    4. 提出修改搜索策略的建议，如更换或细化关键词，以提高未来搜索的相关性和效果。
                    
                    示例：
                        搜索关键词：'Apache Struts OGNL injection'
                        搜索结果：'Apache Struts version 2.3.31 RCE vulnerability details'
                        审核步骤：确认搜索结果与关键词的相关性，验证漏洞详情的准确性和目标系统的适用性。
                    
                        如果结果涉及到不相关的框架，如'.NET framework vulnerability'，则标记为不相关，并在报告中指出。
        
        
                你深知：
                * 没有绝对的安全，只有相对的安全。
                * 一个好的攻击方案是成功的一半。
                * 防火墙并不是绝对的障碍，总有绕过的方法。
                * 你的任务是找到最佳和最适合当前情报的攻击方案，而不仅仅是寻找可用的方案。
        
                在审核过程中，你需要：
                1. 核实攻击方案是否充分利用已知情报。
                2. 确保方案的实施方式与目标技术栈兼容。
                3. 评估方案的可行性，避免使用不匹配或过时的攻击策略。
                4. 优化方案，以提高攻击成功率和效率。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def attackPlanReviewCrew(self, assets: str, intelligence: str, plan: str, review: str | None = None):
        agents = []
        tasks = []
        tools = self._getKnowledgeTools()

        ag = self.agent_attack_plan_review_expert(self.llm, tools)
        agents.append(ag)

        tasks.append(self.task_attack_surface_research(ag, assets, intelligence))
        tasks.append(self.task_establishing_foothold_research(ag))
        tasks.append(self.task_attack_plan_review(ag, assets, intelligence, plan))

        if review is not None:
            tasks.append(self.task_establishing_foothold_research_rework(ag, plan, review))

        logger.info("初始化智能体 攻击方案审核")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False,
            cache=True
        )
