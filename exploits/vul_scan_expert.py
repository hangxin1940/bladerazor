from ipaddress import ip_address
from textwrap import dedent

import validators
from crewai import Agent, Task, Crew
from crewai_tools import BaseTool
from sqlalchemy import select, and_

from exploits.scanner.nuclei_scanner_tool import NucleiScannerTool
from exploits.web.gobuster_dir_tool import GobusterDirTool
from exploits.web.host_crawler_tool import HostCrawlerTool
from helpers.utils import is_domain
from persistence.database import DB
from config import logger
from persistence.orm import WebInfo, UrlEnum


class VulScanExpert:
    """
    漏洞分析专家
    根据已探明的网络资产，进行漏洞分析。
    """

    # TODO
    def __init__(self, db: DB, llm=None, nuclei_path: str = None, nuclei_templates_path: str = None,
                 gobuster_path: str = None, gobuster_wordlist_path: str = None,
                 verbose: bool = False):
        self.llm = llm
        self.db = db
        self.nuclei_path = nuclei_path
        self.nuclei_templates_path = nuclei_templates_path
        self.gobuster_path = gobuster_path
        self.gobuster_wordlist_path = gobuster_wordlist_path
        self.verbose = verbose

    def agent_cyber_assets_fingerprinting_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 网络资产指纹识别专家")
        agent = Agent(
            role='网络资产指纹识别专家',
            goal='对网络资产进行指纹识别，最终掌握目标的所有特征，为后续工作打下基础。',
            backstory=dedent(
                """
                你是一名经验丰富的网络资产指纹识别专家，隶属于攻击团队。
                你的主要任务是利用指纹识别工具分析网络服务的特征，例如端口提供的服务、web程序的开发语言、web程序使用的中间件等等。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def task_cyber_assets_fingerprinting(self, agent: Agent, target: str) -> Task:
        logger.info("初始化任务 网络资产指纹识别")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                使用多种指纹识别工具对目标进行指纹识别，为漏洞扫描和利用提供基础信息:
                - 探明暴露的TCP/UDP端口的服务, 例如探明某个端口是SSH服务还是HTTP服务，以及服务的版本信息。
                - 探明Web应用程序的类型和版本信息，例如探明某个Web应用程序是WordPress还是Joomla，以及Web应用程序的版本信息。
                
                目标: `{target}`
                """),
            expected_output=dedent(
                """
                最终答案是本次探测结果数量，具体的结果已存储在数据库中。不要编造其他额外内容。
                """),
        )

    def _getFingerPrintingTools(self, task_id: int, target) -> []:
        tools = []
        if validators.url(target) or is_domain(target):
            tools.append(HostCrawlerTool(self.db, task_id))
        return tools

    def _fingerPrintingCrew(self, task_id: int, target: str):

        agents = []
        tasks = []
        tools = self._getFingerPrintingTools(task_id, target)

        if len(tools) > 0:
            ag = self.agent_cyber_assets_fingerprinting_expert(self.llm, tools)
            agents.append(ag)

            tasks.append(self.task_cyber_assets_fingerprinting(ag, target))

        if len(agents) == 0 or len(tasks) == 0:
            raise Exception("无可用工具")

        logger.info("初始化智能体 指纹识别")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False
        )

    def fingerprintingCrew(self, task_id: int, target: str):
        if validators.url(target):
            # url
            logger.info("url目标 {}", target)
        elif is_domain(target):
            # domain
            logger.info("domain目标 {}", target)
        else:
            try:
                ip_address(target)
                logger.info("IP目标 {}", target)
            except ValueError:
                raise ValueError("目标类型不支持")
        return self._fingerPrintingCrew(task_id, target)

    def do_directory_bruteforcing(self, task_id: int):

        datas = []
        with self.db.DBSession() as session:
            subquery = select(UrlEnum.web_info_id).where(UrlEnum.task_id == task_id).subquery()
            infos = session.query(WebInfo).filter(
                and_(
                    WebInfo.task_id == task_id),
                WebInfo.id.notin_(subquery)
            ).all()
            for info in infos:
                datas.append((info.id, info.url))

        for id, url in datas:
            gobuster = GobusterDirTool(self.db, task_id, id, self.gobuster_path, self.gobuster_wordlist_path)
            gobuster.run(url=url)

    def _getVulScanTools(self, task_id: int) -> []:
        tools = []
        if self.nuclei_path and self.nuclei_templates_path:
            tools.append(
                NucleiScannerTool(self.db, task_id, nuclei_path=self.nuclei_path,
                                  templates_path=self.nuclei_templates_path))
        return tools

    def agent_vulnerability_scanning_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 漏扫专家")
        agent = Agent(
            role='漏洞扫描专家',
            goal='对网络资产进行漏洞扫描，以发现潜在的漏洞和弱点',
            backstory=dedent(
                """
                你是一名经验丰富的漏洞扫描专家，隶属于攻击团队。
                你的主要任务是利用各种工具对目标进行漏洞扫描，以发现漏洞利用点、关键信息的泄漏、以及其他对渗透有用的各种信息。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def task_vulnerability_scanning_expert(self, agent: Agent, target: str) -> Task:
        logger.info("初始化任务 漏洞扫描")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                对目标进行全面的漏洞扫描，发现尽可能多的安全漏洞。

                目标: `{target}`
                """),
            expected_output=dedent(
                """
                最终答案是本次探测结果数量，具体的结果已存储在数据库中。不要编造其他额外内容。
                """),
        )

    def vulScanCrew(self, task_id: int, target: str):
        if validators.url(target):
            # url
            logger.info("url目标 {}", target)
        elif is_domain(target):
            # domain
            logger.info("domain目标 {}", target)
        else:
            try:
                ip_address(target)
                logger.info("IP目标 {}", target)
            except ValueError:
                raise ValueError("目标类型不支持")

        agents = []
        tasks = []
        tools = self._getVulScanTools(task_id)

        if len(tools) > 0:
            ag = self.agent_vulnerability_scanning_expert(self.llm, tools)
            agents.append(ag)

            tasks.append(self.task_vulnerability_scanning_expert(ag, target))

        if len(agents) == 0 or len(tasks) == 0:
            raise Exception("无可用工具")

        logger.info("初始化智能体 漏洞扫描")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False
        )
