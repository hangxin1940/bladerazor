from ipaddress import ip_address
from textwrap import dedent

import validators
from crewai import Agent, Task, Crew
from crewai_tools import BaseTool

from exploits.nuclei_scanner_tool import NucleiScannerTool
from exploits.web.host_crawler_tool import HostCrawlerTool
from helpers.utils import is_domain
from persistence.database import DB
from config import logger
from rag.rag import RAG
from rag.rag_search_tool import RagSearchTool


class CybersecurityExperts:
    """
    漏洞分析与利用专家
    根据已探明的网络资产，进行漏洞分析与利用。
    """

    # TODO
    def __init__(self, db: DB, rag: RAG, llm=None, nuclei_path: str = None, templates_path: str = None,
                 verbose: bool = False):
        self.llm = llm
        self.db = db
        self.rag = rag
        self.nuclei_path = nuclei_path
        self.templates_path = templates_path
        self.verbose = verbose

    def agent_cyber_assets_fingerprinting_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 网络资产指纹识别专家")
        agent = Agent(
            role='网络资产指纹识别专家',
            goal='对网络资产进行指纹识别，最终掌握目标的所有特征，为后续工作打下基础。',
            backstory=dedent(
                """
                你是一名经验丰富的网络资产指纹识别专家，隶属于攻击团队。
                你的主要任务是利用指纹识别工具分析网络服务的特征，例如端口提供的服务、web程序的开发语言、web程序使用的中间件等等。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def task_cyber_assets_fingerprinting(self, agent: Agent, target: str) -> Task:
        logger.info("初始化任务 网络资产指纹识别")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                使用多种指纹识别工具对目标进行指纹识别，为漏洞扫描和利用提供基础信息。:
                - 探明暴露的TCP/UDP端口的服务, 例如探明某个端口是SSH服务还是HTTP服务，以及服务的版本信息。
                - 探明Web应用程序的类型和版本信息，例如探明某个Web应用程序是WordPress还是Joomla，以及Web应用程序的版本信息。
                
                目标: `{target}`
                """),
            expected_output=dedent(
                """
                最终答案是本次探测结果数量，具体的结果已存储在数据库中。不要编造其他额外内容。
                """),
        )

    def _getFingerPrintingTools(self, task_id: int, target) -> []:
        tools = []
        if validators.url(target) or is_domain(target):
            tools.append(HostCrawlerTool(self.db, task_id))
        return tools

    def _fingerPrintingCrew(self, task_id: int, target: str):

        agents = []
        tasks = []
        tools = self._getFingerPrintingTools(task_id, target)

        if len(tools) > 0:
            ag = self.agent_cyber_assets_fingerprinting_expert(self.llm, tools)
            agents.append(ag)

            tasks.append(self.task_cyber_assets_fingerprinting(ag, target))

        if len(agents) == 0 or len(tasks) == 0:
            raise Exception("无可用工具")

        logger.info("初始化智能体 指纹识别")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False
        )

    def fingerprintingCrew(self, task_id: int, target: str):
        if validators.url(target):
            # url
            logger.info("url目标 {}", target)
        elif is_domain(target):
            # domain
            logger.info("domain目标 {}", target)
        else:
            try:
                ip_address(target)
                logger.info("IP目标 {}", target)
            except ValueError:
                ValueError("目标类型不支持")
        return self._fingerPrintingCrew(task_id, target)

    def _getVulScanTools(self, task_id: int) -> []:
        tools = []
        if self.nuclei_path and self.templates_path:
            tools.append(
                NucleiScannerTool(self.db, task_id, nuclei_path=self.nuclei_path, templates_path=self.templates_path))
        return tools

    def agent_vulnerability_scanning_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 漏扫专家")
        agent = Agent(
            role='漏洞扫描专家',
            goal='对网络资产进行漏洞扫描，以发现潜在的漏洞和弱点',
            backstory=dedent(
                """
                你是一名经验丰富的漏洞扫描专家，隶属于攻击团队。
                你的主要任务是利用各种工具对目标进行漏洞扫描，以发现漏洞利用点、关键信息的泄漏、以及其他对渗透有用的各种信息。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=False,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def task_vulnerability_scanning_expert(self, agent: Agent, target: str) -> Task:
        logger.info("初始化任务 漏洞扫描")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                对目标进行全面的漏洞扫描，发现尽可能多的安全漏洞。

                目标: `{target}`
                """),
            expected_output=dedent(
                """
                最终答案是本次探测结果数量，具体的结果已存储在数据库中。不要编造其他额外内容。
                """),
        )

    def vulScanCrew(self, task_id: int, target: str):
        if validators.url(target):
            # url
            logger.info("url目标 {}", target)
        elif is_domain(target):
            # domain
            logger.info("domain目标 {}", target)
        else:
            try:
                ip_address(target)
                logger.info("IP目标 {}", target)
            except ValueError:
                ValueError("目标类型不支持")

        agents = []
        tasks = []
        tools = self._getVulScanTools(task_id)

        if len(tools) > 0:
            ag = self.agent_vulnerability_scanning_expert(self.llm, tools)
            agents.append(ag)

            tasks.append(self.task_vulnerability_scanning_expert(ag, target))

        if len(agents) == 0 or len(tasks) == 0:
            raise Exception("无可用工具")

        logger.info("初始化智能体 漏洞扫描")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False
        )

    def task_attack_surface_research(self, agent: Agent, target: str) -> Task:
        logger.info("初始化任务 攻击面研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                对目标的技术栈、指纹信息、暴露的端口服务以及漏扫结果进行深入分析研究，以找到所有可能的攻击面。
                
                {target}
                """),
            expected_output=dedent(
                """
                最终答案是你发现的所有攻击面列表。
                """),
        )

    def task_establishing_foothold_research(self, agent: Agent) -> Task:
        logger.info("初始化任务 打点研究")
        return Task(
            agent=agent,
            description=dedent(
                f"""
                根据攻击面列表，结合本地知识库，为每一个攻击面找到所有攻击方法。
                
                使用知识库时注意以下几点：
                * 识别目标信息中的不同实体，如技术栈、服务、组件、端口信息等，多次进行查询。
                * 不要查询目标的ip、网址等信息，这些信息已知且无意义。
                * 问题必须具有通用性，不能是具体的目标信息。
                * 不要进行无意义的查询。
                
                注意一些基本原则:
                * 注意漏洞与目标是否匹配，如一个java框架的漏洞并不适用于一个php框架。
                * 注意漏洞的利用条件，如是否需要登录、是否需要特定的请求等。
                * 注意漏洞的利用方法，如是否需要上传文件、是否需要执行命令等。
                * 注意漏洞的风险等级，如是否可以获取root权限、是否可以获取敏感信息等。
                * 注意漏洞的利用复杂度，如是否需要特定的环境、是否需要特定的工具等。
                
                你应当确认漏洞的类型、风险等级以及利用复杂度。
                """),
            expected_output=dedent(
                """
                最终答案是每个攻击面的漏洞利用方法，根据严重程度排序，越详细越好。你是攻击队，不需要修复建议，不要编造答案。
                """),
        )

    def agent_establishing_foothold_research_expert(self, llm=None, tools: [BaseTool] = []) -> Agent:
        logger.info("初始化代理 打点研究专家")
        agent = Agent(
            role='打点研究专家',
            goal='根据目标的已知情报，结合本地知识库，研究并制定一套渗透方案',
            backstory=dedent(
                """
                你是一名经验丰富的打点研究专家，隶属于攻击团队。
                你的主要任务是利用已知的各种情报，对目标制定一套渗透方案。
                不要给出修复建议，只需要给出攻击方案。
                你的工作至关重要，你的工作成果将直接影响后续工作的开展。
                """),
            tools=tools,
            verbose=self.verbose,
            allow_delegation=True,
            max_rpm=300,
            # max_iter=1,
            llm=llm,
            cache=True,
        )

        if llm is not None:
            agent.llm = llm
        return agent

    def _getKnowledgeTools(self) -> []:
        tools = []
        tools.append(RagSearchTool(self.rag))
        return tools

    def establishingFootholdResearchCrew(self, target: str):

        agents = []
        tasks = []
        tools = self._getKnowledgeTools()

        ag = self.agent_establishing_foothold_research_expert(self.llm, tools)
        agents.append(ag)

        tasks.append(self.task_attack_surface_research(ag, target))
        tasks.append(self.task_establishing_foothold_research(ag))

        logger.info("初始化智能体 打点研究")
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=self.verbose,
            share_crew=False,
            cache=True
        )
